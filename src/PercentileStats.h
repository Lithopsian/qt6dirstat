/*
 *   File name: PercentileStats.h
 *   Summary:   Statistics classes for QDirStat
 *   License:   GPL V2 - See file LICENSE for details.
 *
 *   Authors:   Stefan Hundhammer <Stefan.Hundhammer@gmx.de>
 *              Ian Nartowicz
 */

#ifndef PercentileStats_h
#define PercentileStats_h

#include <cmath>     // cbrt(), floor()

#include <QVector>

#include "Typedefs.h" // FileCount


namespace QDirStat
{
    typedef qint64                      PercentileValue;
    typedef long double                 PercentileBoundary;
    typedef QVector<PercentileBoundary> Percentiles;
    typedef QVector<PercentileValue>    PercentileList;
    typedef QVector<FileCount>          BucketList;

    /**
     * Base class for percentile-related statistics calculation.
     *
     * This class is currently only used to store FileSize (64-bit integer)
     * and time_t (usually 64-bit) integers.  The collected data is held
     * as qint64 64-bit signed integers, capable of holding either FileSize
     * (aka qint64) or 64-bit time_t values.
     *
     * Four lists of values can be calculated and stored for reference:
     * - percentileList with the boundaries between each percentile;
     * - percentileSums with the sum of all values in that percentile;
     * - cumulativeSums with the cumulative sum of values up to a percentile;
     * - buckets with counts of data entries between certain percentiles.
     *
     * The first three lists are generated by calling calculatePercentiles().
     * Values are treated as being in a particular percentile if they are no
     * larger than the cutoff for that percentile and greater than the cutoff
     * for the previous percentile.
     *
     * Percentile boundaries are stored as long double floating point numbers
     * because they may lie between individual 64-bit integer data points.
     * External users of the percentile boundaries (FileSizeStatsWindow,
     * HistogramView, and TreeWalker) only need integers corresponding to
     * their data values, but floating point values are needed for the bucket
     * filling algorithm (although arguably long double precision is overkill
     * for this).
     *
     * The buckets list is generated by calling fillBuckets() with the
     * desired number of buckets and a start percentile and an end percentile.
     * A sensible number of buckets for a particular dataset can be found by
     * calling bestBucketCount().
     *
     * Derived classes have to populate the percentile lists explicitly as
     * they are not needed in all cases.
     **/
    class PercentileStats: public PercentileList
    {

    public:

	/**
	 * Find the minimum value.
	 **/
//	PercentileValue min() const { return quantile( 2, 0 ); }

	/**
	 * Find the maximum value.
	 **/
//	PercentileValue max() const { return quantile( 2, 2 ); }

	/**
	 * Calculate the median.
	 **/
//	PercentileValue median() const { return quantile( 2, 1 ); }

	/**
	 * Calculate a quartile.
	 **/
//	PercentileValue quartile( int number ) const { return quantile( 4, number ); }

	/**
	 * Calculate a percentile directly, without creating or using
	 * _percentiles.  Treewalker uses this for one-off queries and it
	 * is used for populating the _percentiles list.
	 **/
	PercentileBoundary percentile( int number ) const
	    { return quantile( 100, number ); }

	/**
	 * Calculates the percentiles list and sums for this set of data.  Not
	 * done automatically because not all users need this (ie. Treewalker).
	 * The lists it generates are already sorted.
	 *
	 * This is normally only called once per set of collected stats, but is
	 * written to operate safely if called again.
	 **/
	void calculatePercentiles();

	/**
	 * Returns whether the given list is empty.
	 **/
	bool percentileListEmpty() const { return _percentiles.isEmpty();    }
//	bool percentileSumsEmpty() const { return _percentileSums.isEmpty(); }
//	bool cumulativeSumsEmpty() const { return _cumulativeSums.isEmpty(); }

	/**
	 * Returns a particular percentile boundary or sum, for the
	 * given 'index'.
	 **/
	PercentileBoundary percentileBoundary( int index ) const;
	PercentileValue percentileSum( int index ) const;
	PercentileValue cumulativeSum( int index ) const;

	/**
	 * Returns a particular percentile boundary as an integer
	 * value.  For most users, this is more convenient and
	 * matches their integer data values.  The same definition
	 * applies: a data point is a member of a given percentile
	 * if it is no larger than the boundary for that percentile
	 * and greater than the boundary for the previous percentile.
	 * To keep that definition, the floating point boundary
	 * is rounded down to an integer.
	 **/
	PercentileValue percentileValue( int index ) const
	    { return std::floor( percentileBoundary( index ) ); }

	/**
	 * Fill 'bucketCount' buckets of equal width (data value range)
	 * from 'startPercentile' to 'endPercentile'. Each bucket
	 * contains the number of data points (not their value!).
	 **/
	void fillBuckets( int bucketCount, int startPercentile, int endPercentile );

	/**
	 * Calculate the best bucket count according to the Rice Rule for n
	 * data points, but limited to 'max' buckets.
	 *
	 * See also https://en.wikipedia.org/wiki/Histogram
	 **/
	static int bestBucketCount( FileCount n, int max );

	/**
	 * Return the number of buckets for the current buckets list.
	 **/
	int bucketCount() const { return _buckets.size(); }

	/**
	 * Return the start value of bucket no. 'index'
	 **/
	PercentileBoundary bucketStart( int index ) const
	    { return _bucketsStart + index * bucketWidth(); }

	/**
	 * Return the end value of bucket no. 'index'
	 **/
	PercentileBoundary bucketEnd( int index ) const
	    { return bucketStart( index ) + bucketWidth(); }

	/**
	 * Return the total sum of all buckets in the list.
	 **/
	FileCount bucketsTotalSum() const
	    { return std::accumulate( _buckets.cbegin(), _buckets.cend(), 0 ); }

	/**
	 * Return the number of data points in bucket 'index'.
	 **/
	FileCount bucket( int index ) const;

	/**
	 * Iterators for the buckets list.
	 **/
	BucketList::const_iterator bucketsBegin() const { return _buckets.cbegin(); }
	BucketList::const_iterator bucketsEnd()   const { return _buckets.cend();   }


    protected:

	/**
	 * Sort the collected data in ascending order.  This class does not
	 * know if all the data that has been added to the list has been sorted,
	 * so it is vital that sort() is called after all collect() calls are
	 * complete, before the data is analysed.
	 **/
	void sort();

	/**
	 * Calculate a quantile: find the quantile 'number' of order 'order'.
	 *
	 * The median is quantile( 2, 1 ), the minimum is quantile( 2, 0 ), the
	 * maximum is quantile( 2, 2 ). The first quartile is quantile( 4, 1 ),
	 * the first percentile is quantile( 100, 1 ), and the last percentile
	 * is quantile( 100, 100 ).
	 *
	 * The method for this calculation is to find the rank of the
	 * requested quantile and interpolate between the values at the list
	 * positions either side of that rank (eg. rank 75.5 would interpolate
	 * between the values at list positions 75 and 76).
	 *
	 * Rank is defined here as 'number' / 'order' * (size() - 1) (rank is
	 * formally defined as one larger than this but this list starts at index
	 * 0).  This corresponds to the "C = 1" interpolation and is convenient
	 * because it is valid and safe for the entire range of percentiles and
	 * data points.  For example, the "C = 0" method, which may be preferred
	 * on strictly statistical grounds, has the formula 'number' / 'order' *
	 * (size() + 1), but this formula can only be used for percentiles in
	 * the range 1/(size() + 1) to size()/(size() + 1) and the rank must
	 * be explicitly clamped to 1 or size() outside those limits.  The
	 * differences between most of these interpolation methods are small and
	 * for large data sets they are negligible.
	 **/
	PercentileBoundary quantile( int order, int number ) const;

	/**
	 * Return whether the calculated lists have been populated.
	 **/
	bool listsPopulated() const
	    { return !_buckets.isEmpty() && !_percentiles.isEmpty(); }

	/**
	 * Return the width of a bucket. All buckets have the same width.
	 *
	 * Note that this value can only be obtained after all relevant data
	 * are set: buckets, percentiles, startPercentile, endPercentile.
	 **/
	PercentileBoundary bucketWidth() const
	    { return listsPopulated() ? ( _bucketsEnd - _bucketsStart ) / _buckets.size() : 0; }


    private:

	Percentiles    _percentiles;
	PercentileList _percentileSums;
	PercentileList _cumulativeSums;

	PercentileBoundary _bucketsStart{ 0 };
	PercentileBoundary _bucketsEnd{ 0 };
	BucketList         _buckets;

    };	// class PercentileStats

}	// namespace QDirStat

#endif // ifndef PercentileStats_h

