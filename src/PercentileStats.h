/*
 *   File name: PercentileStats.h
 *   Summary:   Statistics classes for QDirStat
 *   License:   GPL V2 - See file LICENSE for details.
 *
 *   Authors:   Stefan Hundhammer <Stefan.Hundhammer@gmx.de>
 *              Ian Nartowicz
 */

#ifndef PercentileStats_h
#define PercentileStats_h

#include <QVector>

#include "Typedefs.h" // FileCount


namespace QDirStat
{
    typedef qint64 PercentileValue;
    typedef long double PercentileBoundary;
    typedef QVector<PercentileBoundary> Percentiles;
    typedef QVector<PercentileValue> PercentileList;
    typedef QVector<FileCount> BucketList;

    /**
     * Base class for percentile-related statistics calculation.
     *
     * This class is currently only used to store FileSize (64-bit integer)
     * and time_t (usually 64-bit) integers.  The collected data is held
     * as qint64 64-bit signed integers, capable of holding either FileSize
     * or time_t.
     *
     * Four lists of values can be calculated and stored for reference:
     * - percentileList with the boundaries between each percentile;
     * - percentileSums with the sum of all values in that percentile;
     * - cumulativeSums with the cumulative sum of values up to a percentile;
     * - buckets with counts of data entries between certain percentiles.
     *
     * The first three lists are generated by calling calculatePercentiles().
     * Percentile boundaries are stored as long double floating point numbers
     * because they may lie between individual data points. Values are treated
     * as being in a particular percentile if they are no larger than the
     * cutoff for that percentile and greater than the cutoff for the previous
     * percentile.
     *
     * The buckets list is generated by calling fillBuckets() with the
     * desired number of buckets and a start percentile and an end percentile.
     * A sensible number of buckets for a particular dataset can be found by
     * calling bestBucketCount().
     *
     * Derived classes have to populate the lists explicitly as they are not
     * needed in all cases.
     **/
    class PercentileStats: public PercentileList
    {

    public:

	/**
	 * Find the minimum value.
	 **/
//	PercentileValue min() const { return quantile( 2, 0 ); }

	/**
	 * Find the maximum value.
	 **/
//	PercentileValue max() const { return quantile( 2, 2 ); }

	/**
	 * Calculate the median.
	 **/
//	PercentileValue median() const { return quantile( 2, 1 ); }

	/**
	 * Calculate a quartile.
	 **/
//	PercentileValue quartile( int number ) const { return quantile( 4, number ); }

	/**
	 * Calculate a percentile directly, without creating or using
	 * _percentiles.  Treewalker uses this for one-off queries and it
	 * is used for populating the _percetiles list.
	 **/
	PercentileBoundary percentile( int number ) const
	    { return quantile( 100, number ); }

	/**
	 * Calculates the percentiles list and sums for this set of data.  Not
	 * done automatically because not all users need this (ie. Treewalker).
	 * The lists it generates are already sorted.
	 *
	 * This is normally only called once per set of collected stats, but is
	 * written to operate safely if called again.
	 **/
	void calculatePercentiles();

	/**
	 * Returns whether the given list is empty.
	 **/
	bool percentileListEmpty() const { return _percentiles.isEmpty();    }
//	bool percentileSumsEmpty() const { return _percentileSums.isEmpty(); }
//	bool cumulativeSumsEmpty() const { return _cumulativeSums.isEmpty(); }

	/**
	 * Returns a particular percentile bounary or sum, for the
	 * given 'index'.  For the convenience of datasets countaining
	 * integer data, the bounaries are rounded up to the next whole
	 * number while the sums are rounded.
	 **/
	PercentileValue percentileBoundary( int index ) const;
	PercentileValue percentileSum( int index ) const;
	PercentileValue cumulativeSum( int index ) const;

	/**
	 * Fill 'bucketCount' buckets of equal width (data value range)
	 * from 'startPercentile' to 'endPercentile'. Each bucket
	 * contains the number of data points (not their value!).
	 **/
	void fillBuckets( int bucketCount, int startPercentile, int endPercentile );

	/**
	 * Calculate the best bucket count according to the Rice Rule for n
	 * data points, but limited to 'max' buckets.
	 *
	 * See also https://en.wikipedia.org/wiki/Histogram
	 **/
	static int bestBucketCount( FileCount n, int max );

	/**
	 * Return the number of buckets for the current buckets list.
	 **/
	int bucketCount() const { return _buckets.size(); }

	/**
	 * Return the start value of bucket no. 'index'
	 **/
	PercentileBoundary bucketStart( int index ) const
	    { return _bucketsStart + index * bucketWidth(); }

	/**
	 * Return the end value of bucket no. 'index'
	 **/
	PercentileBoundary bucketEnd( int index ) const
	    { return bucketStart( index ) + bucketWidth(); }

	/**
	 * Return the total sum of all buckets in the list.
	 **/
	FileCount bucketsTotalSum() const
	    { return std::accumulate( _buckets.cbegin(), _buckets.cend(), 0 ); }

	/**
	 * Return the number of data points in bucket 'index'.
	 **/
	FileCount bucket( int index ) const;

	/**
	 * Iterators for the buckets list.
	 **/
	BucketList::const_iterator bucketsBegin() const { return _buckets.cbegin(); }
	BucketList::const_iterator bucketsEnd()   const { return _buckets.cend();   }


    protected:

	/**
	 * Sort the collected data in ascending order.  This class does not
	 * know if all the data that has been added to the list has been sorted,
	 * so it is vital that sort() is called after all collect() calls are
	 * complete, before the data is analysed.
	 **/
	void sort();

	/**
	 * Calculate a quantile: find the quantile 'number' of order 'order'.
	 *
	 * The median is quantile( 2, 1 ), the minimum is quantile( 2, 0 ), the
	 * maximum is quantile( 2, 2 ). The first quartile is quantile( 4, 1 ),
	 * the first percentile is quantile( 100, 1 ), and the last percentile
	 * is quantile( 100, 100 ).
	 **/
	PercentileBoundary quantile( int order, int number ) const;

	/**
	 * Return whether the calculated lists have been populated.
	 **/
	bool listsPopulated() const
	    { return !_buckets.isEmpty() && !_percentiles.isEmpty(); }

	/**
	 * Return the width of a bucket. All buckets have the same width.
	 *
	 * Note that this value can only be obtained after all relevant data
	 * are set: buckets, percentiles, startPercentile, endPercentile.
	 **/
	PercentileBoundary bucketWidth() const
	    { return listsPopulated() ? ( _bucketsEnd - _bucketsStart ) / _buckets.size() : 0.0; }


    private:

	Percentiles    _percentiles;
	PercentileList _percentileSums;
	PercentileList _cumulativeSums;

	PercentileBoundary _bucketsStart{ 0 };
	PercentileBoundary _bucketsEnd{ 0 };
	BucketList         _buckets;

    };	// class PercentileStats

}	// namespace QDirStat

#endif // ifndef PercentileStats_h

