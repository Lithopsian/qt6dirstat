/*
 *   File name: PercentileStats.h
 *   Summary:   Statistics classes for QDirStat
 *   License:   GPL V2 - See file LICENSE for details.
 *
 *   Authors:   Stefan Hundhammer <Stefan.Hundhammer@gmx.de>
 *              Ian Nartowicz
 */

#ifndef PercentileStats_h
#define PercentileStats_h

#include <QVector>


namespace QDirStat
{
    typedef long double PercentileValue;
    typedef QVector<PercentileValue> PercentileList;
    typedef QVector<int> BucketList;

    /**
     * Base class for percentile-related statistics calculation.
     *
     * The collected data is stored as long double floating point numbers.
     * On most platforms, these will be at least 80-bit floats, capable of
     * exactly recording 64-bit (signed) integers, as well as non-integer
     * values.  Larger values can also be stored with some loss of precision.
     * Callers can pass in any type of numeric data that can be implicitly
     * cast to long double and implicitly cast any data value results to
     * the original data type.
     *
     * This class is currently only used to store FileSize (64-bit integer)
     * and time_t (usually 64-bit) integers.
     *
     * Four lists of values can be calculated and stored for reference:
     * - percentileList with the boundaries between each percentile;
     * - percentileSums with the sum of all values in that percentile;
     * - cumulativeSums with the cumulative sum of values up to a percentile;
     * - buckets with counts of data entries between certain percentiles.
     *
     * The first three lists are generated by calling calculatePercentiles().
     * Percentile boundaries are stored as floating point numbers and are
     * often between individual data points, but in some cases will correspond
     * exactly to a data point. Values are treated as being in a particular
     * percentile if they are no larger than the cutoff for that percentile
     * and greater than the cutoff for the previous percentile.
     *
     * The buckets list is generated by calling fillBuckets() with the
     * desired number of buckets and a start percentile and an end percentile.
     * A sensible number of buckets for a particular dataset can be found by
     * calling bestBucketCount().
     *
     * Derived classes have to populate the lists explicitly as they are not
     * needed in all cases.
     **/
    class PercentileStats: public PercentileList
    {

    public:

	/**
	 * Calculate the arithmetic mean of the collected data.
	 **/
//	PercentileValue average() const
//	    { return isEmpty() ? 0.0l : std::accumulate( cbegin(), cend(), 0.0l ) / size(); }

	/**
	 * Find the minimum value.
	 **/
//	PercentileValue min() const { return quantile( 2, 0 ); }

	/**
	 * Find the maximum value.
	 **/
//	PercentileValue max() const { return quantile( 2, 2 ); }

	/**
	 * Calculate the median.
	 **/
//	PercentileValue median() const { return quantile( 2, 1 ); }

	/**
	 * Calculate a quartile.
	 **/
//	PercentileValue quartile( int number ) const { return quantile( 4, number ); }

	/**
	 * Calculate a percentile directly, without creating or using
	 * _percentileList.  Treewalker uses this for one-off queries.
	 **/
	PercentileValue percentile( int number ) const { return quantile( 100, number ); }

	/**
	 * Calculates the percentiles list and sums for this set of data.  Not
	 * done automatically because not all users need this (ie. Treewalker).
	 * The lists it generates are already sorted.
	 *
	 * This is normally only called once per set of collected stats, but is
	 * written to operate safely if called again.
	 **/
	void calculatePercentiles();

	/**
	 * Returns the size of the percentiles list (ie. this).
	 **/
//	int percentileListCount() const { return _percentileList.size(); }

	/**
	 * Returns the size of the three percentiles lists.
	 **/
	bool percentileListEmpty() const { return _percentileList.isEmpty(); }
	bool percentileSumsEmpty() const { return _percentileSums.isEmpty(); }
//	bool cumulativeSumsEmpty() const { return _cumulativeSums.isEmpty(); }

	/**
	 * Returns a particular percentile bounary or sum, for the
	 * given 'index'.  For the convenience of datasets countaining
	 * integer data, the bounaries are rounded up to the next whole
	 * number while the sums are rounded.
	 *
	 * Functions returning values for floating point datasets have
	 * a Qt-style different name, but are not currently used.
	 **/
	PercentileValue percentileList( int index ) const { return _percentileList.at( index ); }
	PercentileValue percentileSums( int index ) const { return _percentileSums.at( index ); }
	PercentileValue cumulativeSums( int index ) const { return _cumulativeSums.at( index ); }

	/**
	 * Fill 'bucketCount' buckets of equal width (data value range)
	 * from 'startPercentile' to 'endPercentile'. Each bucket
	 * contains the number of data points (not their value!).
	 **/
	void fillBuckets( int bucketCount,
	                  int startPercentile,
	                  int endPercentile );

	/**
	 * Calculate the best bucket count according to the Rice Rule for n
	 * data points, but limited to 'max' buckets.
	 *
	 * See also https://en.wikipedia.org/wiki/Histogram
	 **/
	static int bestBucketCount( int n, int max );

	/**
	 * Return the number of buckets for the current buckets list.
	 **/
	int bucketCount() const { return _buckets.size(); }

	/**
	 * Return the total sum of all buckets in the list.
	 **/
	int bucketsTotalSum() const
	    { return std::accumulate( _buckets.cbegin(), _buckets.cend(), 0 ); }

	/**
	 * Return the number of data points in bucket 'index'.
	 **/
	int bucket( int index ) const { return _buckets.at( index ); }

	/**
	 * Iterators for the buckets list.
	 **/
	BucketList::const_iterator bucketsBegin() const { return _buckets.cbegin(); }
	BucketList::const_iterator bucketsEnd()   const { return _buckets.cend();   }


    protected:

	/**
	 * Sort the collected data in ascending order.  This class does not
	 * know if all the data that has been added to the list has been sorted,
	 * so it is vital that sort() is called after all collect() calls are
	 * complete, before the data is analysed.
	 **/
	void sort();

	/**
	 * Calculate a quantile: Find the quantile 'number' of order 'order'.
	 *
	 * The median is quantile( 2, 1 ), the minimum is quantile( 2, 0 ), the
	 * maximum is quantile( 2, 2 ). The first quartile is quantile( 4, 1 ),
	 * the first percentile is quantile( 100, 1 ), and the last percentile
	 * is quantile( 100, 100 ).
	 **/
	PercentileValue quantile( int order, int number ) const;


    private:

	PercentileList _percentileList;
	PercentileList _percentileSums;
	PercentileList _cumulativeSums;
	BucketList     _buckets;

    };	// class PercentileStats

}	// namespace QDirStat


#endif // ifndef PercentileStats_h

